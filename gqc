#!/usr/bin/env python3

import argparse
import gzip
import os
import re
import sqlite3
import sys
import math

############################################################################
# UTILITIES
############################################################################

def getfp(filename):
	"""Returns a file pointer for reading based on file name"""
	if   filename.endswith('.gz'):
		return gzip.open(filename, 'rt', encoding='ISO-8859-1')
	elif filename == '-':
		return sys.stdin
	else:
		return open(filename)

def readfasta(filename):
	"""Simple fasta file iterator: yields defline, seq"""
	name = None
	seqs = []
	fp = getfp(filename)
	while True:
		line = fp.readline()
		if line == '': break
		line = line.rstrip()
		if line.startswith('>'):
			if len(seqs) > 0:
				seq = ''.join(seqs)
				yield name, seq
				name = line[1:]
				seqs = []
			else:
				name = line[1:]
		else:
			seqs.append(line)
	yield name, ''.join(seqs)
	fp.close()

COMPLEMENT = str.maketrans('ACGTRYMKWSBDHV', 'TGCAYRKMWSVHDB')

def anti(seq):
	"""Returns the reverse complement of a sequence"""
	anti = seq.translate(COMPLEMENT)[::-1]
	return anti

def prob2score(p):
	"""Convert probability to nucleotide-ish log-odds score"""
	if p == 0: return -100
	return math.log2(p/0.25)

############################################################################
# MARKOV MODEL
############################################################################


def create_markov(seqs, order, beg, end):
	"""Creates an n-th order Markov model from a list of sequences"""
	count = {}
	for seq in seqs:
		for i in range(beg+order, len(seq) - end):
			ctx = seq[i-order:i]
			nt = seq[i]
			if ctx not in count: count[ctx] = {'A':0, 'C':0, 'G':0, 'T':0}
			count[ctx][nt] += 1

	# these need to be probabilities
	mm = {}
	for kmer in count:
		mm[kmer] = {}
		total = 0
		for nt in count[kmer]: total += count[kmer][nt]
		for nt in count[kmer]: mm[kmer][nt] = count[kmer][nt] / total

	return mm

def write_markov(file, mm):
	"""Writes an n-th order Markov model to a named file"""
	with open(file, 'w') as fp:
		fp.write(f'% MM {file} {len(mm)*4}\n')
		for kmer in sorted(mm):
			for v in mm[kmer]:
				fp.write(f'{kmer}{v} {mm[kmer][v]:.6f}\n')
			fp.write('\n')

def read_markov(file):
	"""Reads an n-th order Markov model from a named file"""
	mm = {}
	k = None
	with open(file) as fp:
		for line in fp:
			if line.startswith('%'): continue
			f = line.split()
			if len(f) == 2:
				mm[f[0]] = prob2score(float(f[1]))
				if k == None: k = len(f[0])
	return {'k': k, 'mm': mm}

def score_markov(model, seq):
	"""Scores an n-th order Markov model against a sequence"""
	score = 0
	k = model['k']
	mm = model['mm']
	for i in range(0, len(seq) -k + 1):
		kmer = seq[i:i+k]
		score += mm[kmer]
	return score

############################################################################
# CLASS DEFINITIONS
############################################################################

class Feature:
	"""represents a genomic feature"""
	def __init__(self, f):
		(sid, src, ft, beg, end, sc, st, ph, fid, pid, info) = f
		self.seqid = sid
		self.source = src
		self.type = ft
		self.beg = beg
		self.end = end
		self.score = sc
		self.strand = st
		self.phase = ph
		self.fid = fid
		self.pid = pid
		self.info = info

	def __str__(self):
		return f'{self.type} {self.beg} {self.end} {self.strand}'

class Gene:
	"""represents a gene"""
	def __init__(self, gf, txs):
		self.seqid = gf.seqid
		self.beg = gf.beg
		self.end = gf.end
		self.strand = gf.strand
		self.score = None # reserved for later
		self.transcripts = txs

	def __str__(self):
		lines = []
		lines.append(f'Gobj: {self.beg} {self.end}')
		for tx in self.transcripts:
			lines.append(f'  {tx}')
			for ex in tx.exons:
				lines.append(f'    {ex}')
		return '\n'.join(lines)

class Transcript:
	def __init__(self, txf):
		# from transcript feature
		self.seqid = txf.seqid
		self.beg = txf.beg
		self.end = txf.end
		self.strand = txf.strand
		self.score = txf.score

		# added to transcript
		self.exons = []
		self.introns = []
		self.cdss = []
		self.utr5s = []
		self.utr3s = []
		self.polya = None

		# calculated later
		self.is_coding = None
		self.is_spliced = None
		self.is_valid = None

	def __str__(self):
		return f'TXobj: {self.beg}..{self.end}{self.strand} {len(self.cdss)}'


############################################################################
# DATABASE FUNCTIONS
############################################################################

def create_database(db, fasta, gff3):
	"""create a new instance of database"""

	if os.path.exists(db): sys.exit(f'aborting: database {db} exists')
	con = sqlite3.connect(db)
	cur = con.cursor()

	# sequences
	cur.execute('CREATE TABLE sequence(seqid TEXT, seq TEXT, info TEXT)')
	cur.execute('CREATE INDEX idx_seq ON sequence (seqid)')
	for header, seq in readfasta(fasta):
		f = header.split()
		if len(f) == 1:
			seqid = f[0]
			info = ''
		else:
			seqid = f[0]
			info = ' '.join(f[1:])
		sql = f'INSERT INTO sequence VALUES ("{seqid}", "{seq}", "{info}")'
		cur.execute(sql)

	# features
	cur.execute('CREATE TABLE feature(seqid TEXT, source TEXT, type TEXT, beg INTEGER, end INTEGER, score NUMERIC, strand TEXT, phase TEXT, fid TEXT, pid TEXT, att TEXT)')
	cur.execute('CREATE INDEX idx_sid ON feature (seqid)')
	cur.execute('CREATE INDEX idx_fid ON feature (fid)')
	cur.execute('CREATE INDEX idx_pid ON feature (pid)')
	cur.execute('CREATE INDEX idx_typ ON feature (type)')
	cur.execute('CREATE INDEX idx_src ON feature (source)')

	grouping = 'ID', 'Parent'

	with getfp(gff3) as fp:
		for line in fp:
			if line.startswith('#'): continue
			f = line.rstrip().split('\t')
			if len(f) != 9: sys.exit('GFF3 requires 9 fields')
			sid, src, typ, beg, end, sc, st, ph, att = f
			info = {k:'' for k in grouping}
			for tv in att.rstrip(';').split(';'):
				tag, value = tv.split('=')
				info[tag] = value

			parent = [] # create duplicate features for multi-parents
			if 'Parent' in info:
				for p in info['Parent'].rstrip(',').split(','):
					parent.append(p)
			else: parent.append('')

			score = 0 if sc == '.' else sc
			fid = info['ID']

			for pid in parent:
				fields = []
				fields.append(f'"{sid}"')
				fields.append(f'"{src}"')
				fields.append(f'"{typ}"')
				fields.append(f'{beg}')
				fields.append(f'{end}')
				fields.append(f'{score}')
				fields.append(f'"{st}"')
				fields.append(f'"{ph}"')
				fields.append(f'"{fid}"')
				fields.append(f'"{pid}"')
				fields.append(f'"{att}"')
				ftxt = ','.join(fields)
				sql = f'INSERT INTO feature VALUES({ftxt})'
				cur.execute(sql)

	con.commit()

def get_seq(db, seqid, beg=None, end=None):
	"""retrieve sequence or subsequence"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	if beg is None and end is None:
		qseq = 'seq'
	elif end is None:
		qseq = f'substr(seq, {beg})'
	elif beg is None:
		qseq = f'substr(seq, 1, {end})'
	else:
		offset = beg
		length = end - beg + 1
		qseq = f'substr(seq, {offset}, {length})'

	query = f'SELECT {qseq} FROM sequence WHERE seqid="{seqid}"'
	seq = cur.execute(query).fetchone()[0]
	return seq

def get_features(db, seqid=None, ftype=None, source=None, fid=None, pid=None):
	"""retrieve features with filters"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	where = []
	if seqid:  where.append(f'seqid="{seqid}"')
	if ftype:  where.append(f'type="{ftype}"')
	if source: where.append(f'source="{source}"')
	if fid:    where.append(f'fid="{fid}"')
	if pid:    where.append(f'pid="{pid}"')
	query = 'select * from feature';
	if where: query += ' WHERE ' + ' and '.join(where)
	for f in cur.execute(query).fetchall(): yield Feature(f)

def get_seqfeats(db, seqid=None, ftype=None, source=None):
	"""retrive sequences of features with filters"""

	for f in get_features(db, seqid=seqid, ftype=ftype, source=source):
		seq = get_seq(db, f.seqid, beg=f.beg, end=f.end)
		yield seq

def get_genes(db,  seqid=None, source=None, fid=None, pid=None):
	"""retrieve all protein-coding genes"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	for genef in get_features(db, ftype='gene'):
		# find all transcripts where pid == fid
		txos = []
		for txf in get_features(db, pid=genef.fid):
			txo = Transcript(txf)
			for f in get_features(db, pid=txf.fid):
				if   f.type == 'exon': txo.exons.append(f)
				elif f.type == 'intron': txo.introns.append(f)
				elif f.type == 'CDS': txo.cdss.append(f)
				elif f.type == 'five_prime_UTR': txo.utr5s.append(f)
				elif f.type == 'three_prime_UTR': txo.utr3s.append(f)
				else: sys.exit(f'unknown ftype for tx: {f.type}')
			txos.append(txo)
		yield Gene(genef, txos)


############################################################################
# ACTIONS
############################################################################

def cli_create_database(arg):
	create_database(arg.db, arg.fasta, arg.gff3)

def cli_get_seq(arg):
	seq = get_seq(arg.db, arg.chrom, arg.beg, arg.end)
	print(seq)
	# change to fasta

def cli_get_features(arg):
	for f in get_features(arg.db, arg.chrom, arg.ftype, arg.source):
		print(f)
		# change to gff

def cli_get_seqfeats(arg):
	for s in get_seqfeats(arg.db, arg.chrom, arg.ftype, arg.source):
		print(s)
		# change to fasta

def cli_get_genes(arg):
	for gene in get_genes(arg.db):
		print(gene)

def cli_train_models(arg):
	accs = []
	dons = []
	for gene in get_genes(arg.db):
		for tx in gene.transcripts:
			for intron in tx.introns:
				iseq = get_seq(arg.db, intron.seqid, beg=intron.beg, end=intron.end)
				if intron.strand == '-': iseq = anti(iseq)
				dons.append(iseq[0:arg.don])
				accs.append(iseq[-arg.acc:])

def cli_find_bad_genes(arg):
	badgenes = []
	eseqs = []
	iseqs = []

	for gene in get_genes(arg.db):
		for tx in gene.transcripts:
			score = 0
			for exon in tx.exons:
				eseq = get_seq(arg.db, exon.seqid, beg=exon.beg, end=exon.end)
				eseqs.append(eseq)
			for intron in tx.introns:
				iseq = get_seq(arg.db, intron.seqid, beg=intron.beg, end=intron.end)
				iseqs.append(iseq)
				
	mmexon = create_markov(eseqs, 3, 0, 0)
	mmintron = create_markov(iseqs, 3, 0 ,0)

	for gene in get_genes(arg.db):
		for tx in gene.transcripts:
			score = 0
			for exon in tx.exons:
				eseq = get_seq(arg.db, exon.seqid, beg=exon.beg, end=exon.end)
				score += score_markov(mmexon, eseq)
			for intron in tx.introns:
				iseq = get_seq(arg.db, intron.seqid, beg=intron.beg, end=intron.end)
				score += score_markov(mmintron, iseq)
			if score < 0:
				badgenes.append((tx,score))

	badgenes.sort(key=lambda tup:tup[1],reverse=True)
	for tx, score in badgenes:
		print(f'{tx}   \t{score}')

#	import isoform
#	acc = isoform.create_pwm(accs)

############################################################################
# CLI
############################################################################

## parent parser
parser = argparse.ArgumentParser()
parser.add_argument('--db', metavar='<file.db>', default='genome.db',
	help='genome database file [%(default)s]')
sub = parser.add_subparsers(required=True, help='sub-commands')

## create genome database
s1 = sub.add_parser('create',
	help='create a genome database from fasta and gff3 files')
s1.add_argument('--fasta', metavar='<file.fa>', required=True,
	help='genome fasta file, compressed ok')
s1.add_argument('--gff3', metavar='<file.gff3>', required=True,
	help='genome gff3 file, compressed ok')
s1.set_defaults(func=cli_create_database)

## get sequence using coordinates
s2 = sub.add_parser('getseq', help='get sequences or subsequences as FASTA')
s2.add_argument('--chrom', metavar='<name>', required=True,
	help='chromosome name [defaults to all]')
s2.add_argument('--beg', type=int, metavar='<int>', help='beg of subsequence')
s2.add_argument('--end', type=int, metavar='<int>', help='end of subsequence')
s2.add_argument('--anti', action='store_true',
	help='reverse complement the sequence after retrieval')
s2.set_defaults(func=cli_get_seq)

## get features
s3 = sub.add_parser('features', help='get features')
s3.add_argument('--chrom', help='limit to specific chromosome(s)')
s3.add_argument('--ftype', help='limit to specific type(s)')
s3.add_argument('--source', help='limit to specific source(s)')
s3.set_defaults(func=cli_get_features)

## get sequences of features
s4 = sub.add_parser('seqfeats', help='get sequences of features')
s4.add_argument('--chrom', help='limit to specific chromosome(s)')
s4.add_argument('--source', help='limit to specific source(s)')
s4.add_argument('--ftype', help='limit to specific type(s)')
s4.add_argument('--plus', action='store_true',
	help='convert sequence to + strand')
s4.set_defaults(func=cli_get_seqfeats)

## get genes and transcripts
s5 = sub.add_parser('genes', help='get genes')
s5.add_argument('--source')
s5.add_argument('--seq', action='store_true', help='report sequence')
s5.add_argument('--tx', help='send transcripts to named file')
s5.add_argument('--cds', help='send CDS to named file')
s5.set_defaults(func=cli_get_genes)

## get splice sites
s6 = sub.add_parser('models', help='get splice sites')
s6.add_argument('--acc', type=int, default=6,
	help='length of acceptor site [%(default)i]')
s6.add_argument('--don', type=int, default=5,
	help='length of donor site [%(default)i]')
s6.add_argument('--exon', type=int, default=5,
	help='order of Markov model [%(default)i]')
s6.add_argument('--intron', type=int, default=5,
	help='order of Markov model [%(default)i]')
s6.set_defaults(func=cli_train_models)

## score markov
s7 = sub.add_parser('findbgs', help='get unlikely transcripts')
s7.set_defaults(func=cli_find_bad_genes)

## execute sub-command
arg = parser.parse_args()
arg.func(arg)
