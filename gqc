#!/usr/bin/env python3

import argparse
import gzip
import os
import re
import sqlite3
import sys

############################################################################
# UTILITIES
############################################################################

def getfp(filename):
	"""Returns a file pointer for reading based on file name"""
	if   filename.endswith('.gz'):
		return gzip.open(filename, 'rt', encoding='ISO-8859-1')
	elif filename == '-':
		return sys.stdin
	else:
		return open(filename)

def readfasta(filename):
	"""Simple fasta file iterator: yields defline, seq"""
	name = None
	seqs = []
	fp = getfp(filename)
	while True:
		line = fp.readline()
		if line == '': break
		line = line.rstrip()
		if line.startswith('>'):
			if len(seqs) > 0:
				seq = ''.join(seqs)
				yield name, seq
				name = line[1:]
				seqs = []
			else:
				name = line[1:]
		else:
			seqs.append(line)
	yield name, ''.join(seqs)
	fp.close()


############################################################################
# CLASS DEFINITIONS
############################################################################

class Feature:
	"""represents a genomic feature"""
	def __init__(self, f):
		(sid, src, ft, beg, end, sc, st, ph, fid, pid, info) = f
		self.seqid = sid
		self.source = src
		self.type = ft
		self.beg = beg
		self.end = end
		self.score = sc
		self.strand = st
		self.phase = ph
		self.fid = fid
		self.pid = pid
		self.info = info

	def __str__(self):
		return f'{self.type} {self.beg} {self.end} {self.strand}'

class Gene:
	"""represents a gene"""
	def __init__(self, gf, txs):
		self.seqid = gf.seqid
		self.beg = gf.beg
		self.end = gf.end
		self.strand = gf.strand
		self.score = None # reserved for later
		self.transcripts = txs

	def __str__(self):
		lines = []
		lines.append(f'Gobj: {self.beg} {self.end}')
		for tx in self.transcripts:
			lines.append(f'  {tx}')
			for ex in tx.exons:
				lines.append(f'    {ex}')
		return '\n'.join(lines)

class Transcript:
	def __init__(self, txf):
		# from transcript feature
		self.seqid = txf.seqid
		self.beg = txf.beg
		self.end = txf.end
		self.strand = txf.strand
		self.score = txf.score

		# added to transcript
		self.exons = []
		self.introns = []
		self.cdss = []
		self.utr5s = []
		self.utr3s = []
		self.polya = None

		# calculated later
		self.is_coding = None
		self.is_spliced = None
		self.is_valid = None

	def __str__(self):
		return f'TXobj: {self.beg}..{self.end}{self.strand} {len(self.cdss)}'


############################################################################
# DATABASE FUNCTIONS
############################################################################

def create_database(db, fasta, gff3):
	"""create a new instance of database"""

	if os.path.exists(db): sys.exit(f'aborting: database {db} exists')
	con = sqlite3.connect(db)
	cur = con.cursor()

	# sequences
	cur.execute('CREATE TABLE sequence(seqid TEXT, seq TEXT, info TEXT)')
	cur.execute('CREATE INDEX idx_seq ON sequence (seqid)')
	for header, seq in readfasta(fasta):
		f = header.split()
		if len(f) == 1:
			seqid = f[0]
			info = ''
		else:
			seqid = f[0]
			info = ' '.join(f[1:])
		sql = f'INSERT INTO sequence VALUES ("{seqid}", "{seq}", "{info}")'
		cur.execute(sql)

	# features
	cur.execute('CREATE TABLE feature(seqid TEXT, source TEXT, type TEXT, beg INTEGER, end INTEGER, score NUMERIC, strand TEXT, phase TEXT, fid TEXT, pid TEXT, att TEXT)')
	cur.execute('CREATE INDEX idx_sid ON feature (seqid)')
	cur.execute('CREATE INDEX idx_fid ON feature (fid)')
	cur.execute('CREATE INDEX idx_pid ON feature (pid)')
	cur.execute('CREATE INDEX idx_typ ON feature (type)')
	cur.execute('CREATE INDEX idx_src ON feature (source)')

	grouping = 'ID', 'Parent'

	with getfp(gff3) as fp:
		for line in fp:
			if line.startswith('#'): continue
			f = line.rstrip().split('\t')
			if len(f) != 9: sys.exit('GFF3 requires 9 fields')
			sid, src, typ, beg, end, sc, st, ph, att = f
			info = {k:'' for k in grouping}
			for tv in att.rstrip(';').split(';'):
				tag, value = tv.split('=')
				info[tag] = value

			parent = [] # create duplicate features for multi-parents
			if 'Parent' in info:
				for p in info['Parent'].rstrip(',').split(','):
					parent.append(p)
			else: parent.append('')

			score = 0 if sc == '.' else sc
			fid = info['ID']

			for pid in parent:
				fields = []
				fields.append(f'"{sid}"')
				fields.append(f'"{src}"')
				fields.append(f'"{typ}"')
				fields.append(f'{beg}')
				fields.append(f'{end}')
				fields.append(f'{score}')
				fields.append(f'"{st}"')
				fields.append(f'"{ph}"')
				fields.append(f'"{fid}"')
				fields.append(f'"{pid}"')
				fields.append(f'"{att}"')
				ftxt = ','.join(fields)
				sql = f'INSERT INTO feature VALUES({ftxt})'
				cur.execute(sql)

	con.commit()

def get_seq(db, seqid, beg=None, end=None):
	"""retrieve sequence or subsequence"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	if beg is None and end is None:
		qseq = 'seq'
	elif end is None:
		qseq = f'substr(seq, {beg})'
	elif beg is None:
		qseq = f'substr(seq, 1, {end})'
	else:
		offset = beg
		length = end - beg + 1
		qseq = f'substr(seq, {offset}, {length})'

	query = f'SELECT {qseq} FROM sequence WHERE seqid="{seqid}"';
	seq = cur.execute(query).fetchone()[0]
	return seq

def get_features(db, seqid=None, ftype=None, source=None, fid=None, pid=None):
	"""retrieve features with filters"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	where = []
	if seqid:  where.append(f'seqid="{seqid}"')
	if ftype:  where.append(f'type="{ftype}"')
	if source: where.append(f'source="{source}"')
	if fid:    where.append(f'fid="{fid}"')
	if pid:    where.append(f'pid="{pid}"')
	query = 'select * from feature';
	if where: query += ' WHERE ' + ' and '.join(where)
	for f in cur.execute(query).fetchall(): yield Feature(f)

def get_seqfeats(db, seqid=None, ftype=None, source=None):
	"""retrive sequences of features with filters"""

	for f in get_features(db, seqid=seqid, ftype=ftype, source=source):
		seq = get_seq(db, f.seqid, beg=f.beg, end=f.end)
		yield seq

def get_genes(db,  seqid=None, source=None, fid=None, pid=None):
	"""retrieve all protein-coding genes"""

	if not os.path.exists(db): sys.exit(f'aborting: no database {db}')
	con = sqlite3.connect(db)
	cur = con.cursor()

	for genef in get_features(db, ftype='gene'):
		# find all transcripts where pid == fid
		txos = []
		for txf in get_features(db, pid=genef.fid):
			txo = Transcript(txf)
			for f in get_features(db, pid=txf.fid):
				if   f.type == 'exon': txo.exons.append(f)
				elif f.type == 'intron': txo.introns.append(f)
				elif f.type == 'CDS': txo.cdss.append(f)
				elif f.type == 'five_prime_UTR': txo.utr5s.append(f)
				elif f.type == 'three_prime_UTR': txo.utr3s.append(f)
				else: sys.exit(f'unknown ftype for tx: {f.type}')
			txos.append(txo)
		yield Gene(genef, txos)

############################################################################
# ACTIONS
############################################################################

def cli_create_database(arg):
	create_database(arg.db, arg.fasta, arg.gff3)

def cli_get_seq(arg):
	seq = get_seq(arg.db, arg.chrom, arg.beg, arg.end)
	print(seq)
	# change to fasta

def cli_get_features(arg):
	for f in get_features(arg.db, arg.chrom, arg.ftype, arg.source):
		print(f)
		# change to gff

def cli_get_seqfeats(arg):
	for s in get_seqfeats(arg.db, arg.chrom, arg.ftype, arg.source):
		print(s)
		# change to fasta

def cli_get_genes(arg):
	for gene in get_genes(arg.db):
		print(gene)


############################################################################
# CLI
############################################################################

## parent parser
parser = argparse.ArgumentParser()
parser.add_argument('--db', metavar='<file.db>', default='genome.db',
	help='genome database file [%(default)s]')
sub = parser.add_subparsers(required=True, help='sub-commands')

## create genome database
s1 = sub.add_parser('create',
	help='create a genome database from fasta and gff3 files')
s1.add_argument('--fasta', metavar='<file.fa>', required=True,
	help='genome fasta file, compressed ok')
s1.add_argument('--gff3', metavar='<file.gff3>', required=True,
	help='genome gff3 file, compressed ok')
s1.add_argument('--index', action='store_true')
s1.set_defaults(func=cli_create_database)

## get sequence using coordinates
s2 = sub.add_parser('getseq', help='get sequences or subsequences as FASTA')
s2.add_argument('--chrom', metavar='<name>', required=True,
	help='chromosome name [defaults to all]')
s2.add_argument('--beg', type=int, metavar='<int>', help='beg of subsequence')
s2.add_argument('--end', type=int, metavar='<int>', help='end of subsequence')
s2.add_argument('--anti', action='store_true',
	help='reverse complement the sequence after retrieval')
s2.set_defaults(func=cli_get_seq)

## get features
s3 = sub.add_parser('features', help='get features')
s3.add_argument('--chrom', help='limit to specific chromosome(s)')
s3.add_argument('--ftype', help='limit to specific type(s)')
s3.add_argument('--source', help='limit to specific source(s)')
s3.set_defaults(func=cli_get_features)

## get sequences of features
s4 = sub.add_parser('seqfeats', help='get sequences of features')
s4.add_argument('--chrom', help='limit to specific chromosome(s)')
s4.add_argument('--source', help='limit to specific source(s)')
s4.add_argument('--ftype', help='limit to specific type(s)')
s4.add_argument('--plus', action='store_true',
	help='convert sequence to + strand')
s4.set_defaults(func=cli_get_seqfeats)

## get genes and transcripts
s5 = sub.add_parser('genes', help='get genes')
s5.add_argument('--source')
s5.add_argument('--seq', action='store_true', help='report sequence')
s5.add_argument('--tx', help='send transcripts to named file')
s5.add_argument('--cds', help='send CDS to named file')
s5.set_defaults(func=cli_get_genes)

## execute sub-command
arg = parser.parse_args()
arg.func(arg)
